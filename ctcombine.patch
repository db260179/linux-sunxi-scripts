diff -ur linux-sunxi.vanilla/drivers/gpio/gpio-sunxi.c linux-sunxi.patched/drivers/gpio/gpio-sunxi.c
--- linux-sunxi.vanilla/drivers/gpio/gpio-sunxi.c	2014-05-11 08:35:02.984624747 +0100
+++ linux-sunxi.patched/drivers/gpio/gpio-sunxi.c	2014-05-11 08:39:06.105569734 +0100
@@ -182,11 +182,9 @@
 	if ((offset > chip->ngpio - 1) || (offset < 0))
 		return -EINVAL;
 
-	/* Set sysfs exported gpio name (example "gpio254_ph20") */
-	sprintf((char *)(chip->names[offset]), "gpio%d_p%c%d",
-		offset+chip->base,
-		'a'+sgpio->data[offset].info.port-1,
-		sgpio->data[offset].info.port_num);
+	/* Set sysfs exported gpio name (example "gpio254") */
+	sprintf((char *)(chip->names[offset]), "gpio%d",
+		offset+chip->base);
 
 	sgpio->data[offset].gpio_handler = gpio_request_ex("gpio_para",
 						sgpio->data[offset].pin_name);
diff -ur linux-sunxi.vanilla/drivers/net/ethernet/allwinner/sunxi_emac.c linux-sunxi.patched/drivers/net/ethernet/allwinner/sunxi_emac.c
--- linux-sunxi.vanilla/drivers/net/ethernet/allwinner/sunxi_emac.c	2014-05-11 08:35:04.008611874 +0100
+++ linux-sunxi.patched/drivers/net/ethernet/allwinner/sunxi_emac.c	2014-05-11 08:38:29.310028294 +0100
@@ -642,6 +642,23 @@
 	return 1;
 }
 
+
+static void sunxi_emac_set_rx_mode(struct net_device *ndev)
+{
+       unsigned int reg_val;
+       sunxi_emac_board_info_t *db = netdev_priv(ndev);
+
+       /* set up RX */
+       reg_val = readl(db->emac_vbase + SUNXI_EMAC_RX_CTL_REG);
+
+       if (ndev->flags & IFF_PROMISC)
+               reg_val |= (0x1<<4);
+       else
+               reg_val &= (~(0x1<<4));
+
+       writel(reg_val, db->emac_vbase + SUNXI_EMAC_RX_CTL_REG);
+}
+
 static void sunxi_emac_set_mac_addr(sunxi_emac_board_info_t *db, unsigned char *buf)
 {
 	writel(buf[0] << 16 | buf[1] << 8 | buf[2],
@@ -1497,7 +1514,7 @@
 	.ndo_stop		= sunxi_emac_stop,
 	.ndo_start_xmit		= sunxi_emac_start_xmit,
 	.ndo_tx_timeout		= sunxi_emac_timeout,
-	.ndo_set_rx_mode	= sunxi_emac_hash_table,
+	.ndo_set_rx_mode        = sunxi_emac_set_rx_mode,
 	.ndo_do_ioctl		= sunxi_emac_ioctl,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
diff -ur linux-sunxi.vanilla/drivers/net/usb/asix.c linux-sunxi.patched/drivers/net/usb/asix.c
--- linux-sunxi.vanilla/drivers/net/usb/asix.c	2014-05-11 08:35:04.344607649 +0100
+++ linux-sunxi.patched/drivers/net/usb/asix.c	2014-05-11 08:38:22.026120453 +0100
@@ -183,6 +183,17 @@
 	__le16 res3;
 } __packed;
 
+struct asix_rx_fixup_info {
+	struct sk_buff *ax_skb;
+	u32 header;
+	u16 size;
+	bool split_head;
+};
+
+struct asix_common_private {
+	struct asix_rx_fixup_info rx_fixup_info;
+};
+
 static int asix_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
 			    u16 size, void *data)
 {
@@ -304,49 +315,89 @@
 	}
 }
 
-static int asix_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+static int asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,
+				  struct asix_rx_fixup_info *rx)
 {
 	int offset = 0;
 
-	while (offset + sizeof(u32) < skb->len) {
-		struct sk_buff *ax_skb;
-		u16 size;
-		u32 header = get_unaligned_le32(skb->data + offset);
-
-		offset += sizeof(u32);
-
-		/* get the packet length */
-		size = (u16) (header & 0x7ff);
-		if (size != ((~header >> 16) & 0x07ff)) {
-			netdev_err(dev->net, "asix_rx_fixup() Bad Header Length\n");
-			return 0;
+	while (offset + sizeof(u16) <= skb->len) {
+		u16 remaining = 0;
+		unsigned char *data;
+
+		if (!rx->size) {
+			if ((skb->len - offset == sizeof(u16)) ||
+			    rx->split_head) {
+				if (!rx->split_head) {
+					rx->header = get_unaligned_le16(
+							skb->data + offset);
+					rx->split_head = true;
+					offset += sizeof(u16);
+					break;
+				} else {
+					rx->header |= (get_unaligned_le16(
+							skb->data + offset)
+							<< 16);
+					rx->split_head = false;
+					offset += sizeof(u16);
+				}
+			} else {
+				rx->header = get_unaligned_le32(skb->data +
+								offset);
+				offset += sizeof(u32);
+			}
+
+			/* get the packet length */
+			rx->size = (u16) (rx->header & 0x7ff);
+			if (rx->size != ((~rx->header >> 16) & 0x7ff)) {
+				netdev_err(dev->net, "asix_rx_fixup() Bad Header Length 0x%x, offset %d\n",
+					   rx->header, offset);
+				rx->size = 0;
+				return 0;
+			}
+			rx->ax_skb = netdev_alloc_skb_ip_align(dev->net,
+							       rx->size);
+			if (!rx->ax_skb)
+				return 0;
 		}
 
-		if ((size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) ||
-		    (size + offset > skb->len)) {
+		if (rx->size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) {
 			netdev_err(dev->net, "asix_rx_fixup() Bad RX Length %d\n",
-				   size);
+				   rx->size);
+			kfree_skb(rx->ax_skb);
 			return 0;
 		}
-		ax_skb = netdev_alloc_skb_ip_align(dev->net, size);
-		if (!ax_skb)
-			return 0;
 
-		skb_put(ax_skb, size);
-		memcpy(ax_skb->data, skb->data + offset, size);
-		usbnet_skb_return(dev, ax_skb);
+		if (rx->size > skb->len - offset) {
+			remaining = rx->size - (skb->len - offset);
+			rx->size = skb->len - offset;
+		}
+
+		data = skb_put(rx->ax_skb, rx->size);
+		memcpy(data, skb->data + offset, rx->size);
+		if (!remaining)
+			usbnet_skb_return(dev, rx->ax_skb);
 
-		offset += (size + 1) & 0xfffe;
+		offset += (rx->size + 1) & 0xfffe;
+		rx->size = remaining;
 	}
 
 	if (skb->len != offset) {
-		netdev_err(dev->net, "asix_rx_fixup() Bad SKB Length %d\n",
-			   skb->len);
+		netdev_err(dev->net, "asix_rx_fixup() Bad SKB Length %d, %d\n",
+			   skb->len, offset);
 		return 0;
 	}
+
 	return 1;
 }
 
+static int asix_rx_fixup_common(struct usbnet *dev, struct sk_buff *skb)
+{
+	struct asix_common_private *dp = dev->driver_priv;
+	struct asix_rx_fixup_info *rx = &dp->rx_fixup_info;
+
+	return asix_rx_fixup_internal(dev, skb, rx);
+}
+
 static struct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
 					gfp_t flags)
 {
@@ -1110,9 +1161,19 @@
 		dev->rx_urb_size = 2048;
 	}
 
+	dev->driver_priv = kzalloc(sizeof(struct asix_common_private),
+				   GFP_KERNEL);
+	if (!dev->driver_priv)
+		return -ENOMEM;
+
 	return 0;
 }
 
+static void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	kfree(dev->driver_priv);
+}
+
 static const struct ethtool_ops ax88178_ethtool_ops = {
 	.get_drvinfo		= asix_get_drvinfo,
 	.get_link		= asix_get_link,
@@ -1445,6 +1506,11 @@
 		dev->rx_urb_size = 2048;
 	}
 
+	dev->driver_priv = kzalloc(sizeof(struct asix_common_private),
+				   GFP_KERNEL);
+	if (!dev->driver_priv)
+		return -ENOMEM;
+
 	return 0;
 }
 
@@ -1491,22 +1557,25 @@
 static const struct driver_info ax88772_info = {
 	.description = "ASIX AX88772 USB 2.0 Ethernet",
 	.bind = ax88772_bind,
+	.unbind = ax88772_unbind,
 	.status = asix_status,
 	.link_reset = ax88772_link_reset,
 	.reset = ax88772_reset,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR | FLAG_MULTI_PACKET,
-	.rx_fixup = asix_rx_fixup,
+	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |
+		 FLAG_MULTI_PACKET,
+	.rx_fixup = asix_rx_fixup_common,
 	.tx_fixup = asix_tx_fixup,
 };
 
 static const struct driver_info ax88178_info = {
 	.description = "ASIX AX88178 USB 2.0 Ethernet",
 	.bind = ax88178_bind,
+	.unbind = ax88772_unbind,
 	.status = asix_status,
 	.link_reset = ax88178_link_reset,
 	.reset = ax88178_reset,
 	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR,
-	.rx_fixup = asix_rx_fixup,
+	.rx_fixup = asix_rx_fixup_common,
 	.tx_fixup = asix_tx_fixup,
 };
 
Only in linux-sunxi.patched/drivers/net/usb: ax88179_178a.c
Only in linux-sunxi.patched/drivers/net/usb: ax88179_178a.h
diff -ur linux-sunxi.vanilla/drivers/net/usb/Kconfig linux-sunxi.patched/drivers/net/usb/Kconfig
--- linux-sunxi.vanilla/drivers/net/usb/Kconfig	2014-05-11 08:35:04.344607649 +0100
+++ linux-sunxi.patched/drivers/net/usb/Kconfig	2014-05-11 08:41:50.895494376 +0100
@@ -157,6 +157,21 @@
 	  This driver creates an interface named "ethX", where X depends on
 	  what other networking devices you have in use.
 
+config USB_NET_AX88179
+        tristate "ASIX AX88179_178A Based USB 3.0/2.0 Gigabit Ethernet Adapters"
+        depends on USB_USBNET
+        select CRC32
+        default y
+        help
+          This option adds support for ASIX AX88179_178A based USB 3.0/2.0
+          10/100/1000 Ethernet adapters.
+
+          This driver should work with at least the following devices:
+            * ASIX AX88179
+
+          This driver creates an interface named "ethX", where X depends on
+          what other networking devices you have in use.
+
 config USB_NET_QF9700
 	tristate "QF9700 Based USB 2.0 Ethernet Adapters"
 	depends on USB_USBNET
diff -ur linux-sunxi.vanilla/drivers/net/usb/Makefile linux-sunxi.patched/drivers/net/usb/Makefile
--- linux-sunxi.vanilla/drivers/net/usb/Makefile	2014-05-11 08:35:04.344607649 +0100
+++ linux-sunxi.patched/drivers/net/usb/Makefile	2014-05-11 08:41:50.903495092 +0100
@@ -9,6 +9,7 @@
 obj-$(CONFIG_USB_HSO)		+= hso.o
 obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
 obj-$(CONFIG_USB_NET_QF9700)	+= qf9700.o
+obj-$(CONFIG_USB_NET_AX88179)      += ax88179_178a.o 
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
 obj-$(CONFIG_USB_NET_CDC_EEM)	+= cdc_eem.o
 obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
diff -ur linux-sunxi.vanilla/drivers/power/axp_power/axp20-mfd.h linux-sunxi.patched/drivers/power/axp_power/axp20-mfd.h
--- linux-sunxi.vanilla/drivers/power/axp_power/axp20-mfd.h	2014-05-11 08:35:04.992599502 +0100
+++ linux-sunxi.patched/drivers/power/axp_power/axp20-mfd.h	2014-05-11 10:32:29.792048728 +0100
@@ -28,29 +28,89 @@
 #include <linux/hwmon.h>
 #include <linux/err.h>
 
-static struct axp_mfd_chip *axp20_update_device(struct device *dev);
+static struct
+axp_mfd_chip *axp20_update_device(struct device *dev, int from_wq);
 
 static ssize_t
 show_temp(struct device *dev, struct device_attribute *devattr, char *buf)
 {
 	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-	struct axp_mfd_chip *data = axp20_update_device(dev);
+	struct axp_mfd_chip *data = axp20_update_device(dev, 0);
 	if (attr->index == 1)
 		return sprintf(buf, "264800\n");
 	if (attr->index == 2)
 		return sprintf(buf, "-144700\n");
+	if (attr->index == 3)
+		return sprintf(buf, "AXP20X temperature\n");
 	return sprintf(buf, "%d\n", data->temperature * 100);
 }
 
+static ssize_t
+show_acin_voltage(struct device *dev, struct device_attribute *devattr,
+		  char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct axp_mfd_chip *data = axp20_update_device(dev, 0);
+	if (attr->index == 3)
+		return sprintf(buf, "ACIN voltage\n");
+	if (attr->index == 4)
+		return sprintf(buf, "%d\n", data->acin_avg_voltage / 64);
+	return sprintf(buf, "%d\n", data->acin_voltage);
+}
+
+static ssize_t
+show_acin_current(struct device *dev, struct device_attribute *devattr,
+		  char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct axp_mfd_chip *data = axp20_update_device(dev, 0);
+	if (attr->index == 3)
+		return sprintf(buf, "ACIN current\n");
+	if (attr->index == 4)
+		return sprintf(buf, "%d\n", data->acin_avg_current / 64);
+	return sprintf(buf, "%d\n", data->acin_current);
+}
+
+static ssize_t
+show_acin_power(struct device *dev, struct device_attribute *devattr, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct axp_mfd_chip *data = axp20_update_device(dev, 0);
+	if (attr->index == 3)
+		return sprintf(buf, "ACIN power\n");
+	if (attr->index == 4)
+		return sprintf(buf, "%d\n", data->acin_avg_power / 64);
+	return sprintf(buf, "%d\n", data->acin_power);
+}
 
 static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL, 0);
 static SENSOR_DEVICE_ATTR(temp1_max, S_IRUGO, show_temp, NULL, 1);
 static SENSOR_DEVICE_ATTR(temp1_min, S_IRUGO, show_temp, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_temp, NULL, 3);
+static SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_acin_voltage, NULL, 0);
+static SENSOR_DEVICE_ATTR(in0_label, S_IRUGO, show_acin_voltage, NULL, 3);
+static SENSOR_DEVICE_ATTR(in0_average, S_IRUGO, show_acin_voltage, NULL, 4);
+static SENSOR_DEVICE_ATTR(curr1_input, S_IRUGO, show_acin_current, NULL, 0);
+static SENSOR_DEVICE_ATTR(curr1_label, S_IRUGO, show_acin_current, NULL, 3);
+static SENSOR_DEVICE_ATTR(curr1_average, S_IRUGO, show_acin_current, NULL, 4);
+static SENSOR_DEVICE_ATTR(power1_input, S_IRUGO, show_acin_power, NULL, 0);
+static SENSOR_DEVICE_ATTR(power1_label, S_IRUGO, show_acin_power, NULL, 3);
+static SENSOR_DEVICE_ATTR(power1_average, S_IRUGO, show_acin_power, NULL, 4);
 
 static struct attribute *axp20_attributes[] = {
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
 	&sensor_dev_attr_temp1_min.dev_attr.attr,
 	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	&sensor_dev_attr_in0_input.dev_attr.attr,
+	&sensor_dev_attr_in0_label.dev_attr.attr,
+	&sensor_dev_attr_in0_average.dev_attr.attr,
+	&sensor_dev_attr_curr1_input.dev_attr.attr,
+	&sensor_dev_attr_curr1_label.dev_attr.attr,
+	&sensor_dev_attr_curr1_average.dev_attr.attr,
+	&sensor_dev_attr_power1_input.dev_attr.attr,
+	&sensor_dev_attr_power1_label.dev_attr.attr,
+	&sensor_dev_attr_power1_average.dev_attr.attr,
 	NULL
 };
 
@@ -58,41 +118,101 @@
 	.attrs = axp20_attributes,
 };
 
+static int axp_read_adc(struct device *dev, struct i2c_client *client, int reg)
+{
+	int err;
+	u8 high, low;
+
+	err = __axp_read(client, reg, &high);
+	if (err) {
+		dev_err(dev, "AXP Error while reading REG 0x%02X\n", reg);
+		high = 0;
+	}
+
+	err = __axp_read(client, reg + 1, &low);
+	if (err) {
+		dev_err(dev, "AXP Error while reading REG 0x%02X\n", reg + 1);
+		low = 0;
+	}
+
+	return (high << 4) + (low & 0x0F);
+}
+
+static int axp_hwmon_wq_counter;
+
+static void axp_hwmon_work_handler(struct work_struct *w);
+static struct workqueue_struct *wq;
+static DECLARE_DELAYED_WORK(axp_hwmon_work, axp_hwmon_work_handler);
+
+static struct device *wq_dev_arg;
+
+static void axp_hwmon_work_handler(struct work_struct *w)
+{
+	axp20_update_device(wq_dev_arg, 1);
+}
 
 /*
  *  * function that update the status of the chips (temperature)
  *   */
-static struct axp_mfd_chip *axp20_update_device(struct device *dev)
+static struct axp_mfd_chip *axp20_update_device(struct device *dev, int from_wq)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct axp_mfd_chip *data = i2c_get_clientdata(client);
-	int err;
-	u8 high, low;
+	int adc_value;
 
 	mutex_lock(&data->lock);
 
-	if (time_after(jiffies, data->last_updated + HZ * 2)
+	if (time_after(jiffies, data->last_updated + HZ / 50)
 		|| !data->valid) {
-		dev_dbg(&client->dev, "Updating axp20 data\n");
+
+		/* AXP202 datasheet page 25, 0x000 means 0A,
+		 * 0xfff means 2.5594A, 4096 steps of 0.625mA */
+		adc_value = axp_read_adc(dev, client, 0x58);
+		data->acin_current = adc_value * 40960 >> 16;
+
+		/* AXP202 datasheet page 25, 0x000 means 0V,
+		 * 0xfff means 6.9615V, 4096 steps of 1.7mV */
+		adc_value = axp_read_adc(dev, client, 0x56);
+		data->acin_voltage = adc_value * 111411 >> 16;
+
 		/* AXP202 datasheet page 25, 0x000 means -144.7,
 		 * 0xfff means 264.8, 4096 steps of 0.1 degress */
-		err = __axp_read(client, 0x5E, &high);
-		if (err) {
-			dev_err(dev, "AXP Error while reading high\n");
-			high = 0;
-		}
+		data->temperature = -1447 + axp_read_adc(dev, client, 0x5E);
+
+		data->acin_power = data->acin_voltage * data->acin_current;
+
+		if (!axp_hwmon_wq_counter || !data->valid) {
+			data->acin_avg_power = 0;
+			data->acin_avg_voltage = 0;
+			data->acin_avg_current = 0;
+		} else {
+			/* Calculate running moving average for N=64 */
+			data->acin_avg_power -= data->acin_avg_power / 64;
+			data->acin_avg_power += data->acin_voltage *
+						data->acin_current;
+
+			data->acin_avg_voltage -= data->acin_avg_voltage / 64;
+			data->acin_avg_voltage += data->acin_voltage;
 
-		err = __axp_read(client, 0x5F, &low);
-		if (err) {
-			dev_err(dev, "AXP Error while reading low\n");
-			low = 0;
+			data->acin_avg_current -= data->acin_avg_current / 64;
+			data->acin_avg_current += data->acin_current;
 		}
 
-		data->temperature = -1447 + ((high << 4) + (low && 0x0F));
 		data->last_updated = jiffies;
 		data->valid = 1;
 	}
 
+	if (from_wq) {
+		if (axp_hwmon_wq_counter > 0) {
+			queue_delayed_work(wq, &axp_hwmon_work, HZ / 25);
+			axp_hwmon_wq_counter--;
+		}
+	} else {
+		/* Keep running for at least 1 minute from now */
+		axp_hwmon_wq_counter = 61 * 25;
+		queue_delayed_work(wq, &axp_hwmon_work, HZ / 25);
+	}
+
 	mutex_unlock(&data->lock);
 	return data;
 }
@@ -151,6 +271,8 @@
 			err = PTR_ERR(chip->hwmon_dev);
 			goto exit_remove_files;
 		}
+		wq_dev_arg = chip->dev;
+		wq = create_singlethread_workqueue("axp_hwmon_wq");
 	} else {
 		dev_info(chip->dev, "AXP internal temperature monitoring disabled\n");
 		/* TODO enable it ?*/
@@ -502,4 +624,4 @@
 	AXP_MFD_ATTR(axp20_ovtemclsen),
 	AXP_MFD_ATTR(axp20_reg),
 	AXP_MFD_ATTR(axp20_regs),
-};
+};
\ No newline at end of file
diff -ur linux-sunxi.vanilla/drivers/power/axp_power/axp-mfd.c linux-sunxi.patched/drivers/power/axp_power/axp-mfd.c
--- linux-sunxi.vanilla/drivers/power/axp_power/axp-mfd.c	2014-05-11 08:35:04.984599603 +0100
+++ linux-sunxi.patched/drivers/power/axp_power/axp-mfd.c	2014-05-11 10:31:29.612780472 +0100
@@ -365,6 +365,10 @@
 
 #ifdef CONFIG_AXP_HWMON
 	if (chip->itm_enabled == 1) {
+		cancel_delayed_work(&axp_hwmon_work);
+		flush_workqueue(wq);
+		destroy_workqueue(wq);
+
 		hwmon_device_unregister(chip->hwmon_dev);
 		sysfs_remove_group(&client->dev.kobj, &axp20_group);
 	}
@@ -399,4 +403,4 @@
 
 MODULE_DESCRIPTION("PMIC MFD Driver for AXP");
 MODULE_AUTHOR("Donglu Zhang Krosspower");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff -ur linux-sunxi.vanilla/drivers/tty/n_tty.c linux-sunxi.patched/drivers/tty/n_tty.c
--- linux-sunxi.vanilla/drivers/tty/n_tty.c	2014-05-11 08:35:05.808589244 +0100
+++ linux-sunxi.patched/drivers/tty/n_tty.c	2014-05-18 19:06:57.000000000 +0100
@@ -1995,8 +1995,10 @@
 			if (tty->ops->flush_chars)
 				tty->ops->flush_chars(tty);
 		} else {
-			while (nr > 0) {
+		       	while (nr > 0) {
+			        mutex_lock(&tty->output_lock);
 				c = tty->ops->write(tty, b, nr);
+				mutex_unlock(&tty->output_lock);
 				if (c < 0) {
 					retval = c;
 					goto break_out;
diff -ur linux-sunxi.vanilla/include/linux/mfd/axp-mfd.h linux-sunxi.patched/include/linux/mfd/axp-mfd.h
--- linux-sunxi.vanilla/include/linux/mfd/axp-mfd.h	2014-05-11 08:35:06.856576070 +0100
+++ linux-sunxi.patched/include/linux/mfd/axp-mfd.h	2014-05-11 10:33:23.743357748 +0100
@@ -133,6 +133,12 @@
 	struct blocking_notifier_head notifier_list;
 #ifdef CONFIG_AXP_HWMON
 	s16 temperature; /* range from -1447 to 2648 */
+	s16 acin_voltage; /* range from 0 to 6962 mV */
+	s16 acin_current; /* range from 0 to 2559 mA */
+	s32 acin_power;
+	s32 acin_avg_voltage;
+	s32 acin_avg_current;
+	s32 acin_avg_power;
 	unsigned long last_updated;     /* in jiffies */
 	char valid;	/* zero until following fields are valid */
 	struct device *hwmon_dev;
@@ -536,4 +542,4 @@
 extern int axp_set_bits(struct device *dev, int reg, uint8_t bit_mask);
 extern int axp_clr_bits(struct device *dev, int reg, uint8_t bit_mask);
 extern struct i2c_client *axp;
-#endif /* __LINUX_PMIC_AXP_H */
+#endif /* __LINUX_PMIC_AXP_H */
\ No newline at end of file
diff -ur linux-sunxi.vanilla/scripts/package/builddeb linux-sunxi.patched/scripts/package/builddeb
--- linux-sunxi.vanilla/scripts/package/builddeb	2014-05-11 08:35:08.708552788 +0100
+++ linux-sunxi.patched/scripts/package/builddeb	2014-05-18 18:36:06.200699063 +0100
@@ -43,7 +43,16 @@
 	mips*)
 		debarch=mips$(grep -q CPU_LITTLE_ENDIAN=y .config && echo el) ;;
 	arm*)
-		debarch=arm$(grep -q CONFIG_AEABI=y .config && echo el) ;;
+				               if grep -q CONFIG_AEABI=y $KCONFIG_CONFIG; then
+                   if grep -q CONFIG_VFP=y $KCONFIG_CONFIG; then
+                       debarch=armhf
+                   else
+                       debarch=armel
+                   fi
+               else
+                   debarch=arm
+               fi
+               ;;
 	*)
 		echo "" >&2
 		echo "** ** **  WARNING  ** ** **" >&2
@@ -116,7 +125,7 @@
 	if [ -e $KBUILD_IMAGE ]; then
 		cp $KBUILD_IMAGE "$tmpdir/boot/vmlinuz-$version"
 	else
-		cp arch/$ARCH/boot/$KBUILD_IMAGE "$tmpdir/boot/vmlinuz-$version"
+		cp arch/$ARCH/boot/uImage "$tmpdir/boot/uImage-$version"
 	fi
 fi
 
@@ -155,6 +164,58 @@
 	chmod 755 "$tmpdir/DEBIAN/$script"
 done
 
+cat <<EOF > "$tmpdir$debhookdir/postinst.d/updateBoot"
+#!/bin/sh
+# Usage updateBoot <KERNEL_VERSION>
+
+tmp_uenv=\$(mktemp /boot/uEnv.XXXXXX)
+  
+if [ -f /etc/armStrap.conf ]; then
+  . /etc/armStrap.conf
+fi
+
+if [ -f /boot/uEnv.ct ]; then
+touch /boot/uEnv.ct
+rm -f /boot/uEnv.bak
+cp /boot/uEnv.ct /boot/uEnv.bak
+awk '/^kernel=/ { skip = 1; } /^dtb=/ { skip = 1; } /.*/ { if (skip) skip = 0; else print \$0; }' /boot/uEnv.ct > \${tmp_uenv}
+echo "kernel=/boot/uImage-\${1}" >> \${tmp_uenv}
+
+if [ -f /boot/\${uboot_kernel_dtb} ]; then
+  echo "dtb=\${uboot_kernel_dtb}" >> \${tmp_uenv}
+fi
+rm -f /boot/uEnv.ct
+mv \${tmp_uenv} /boot/uEnv.ct
+fi
+
+if [ -f /boot/uEnv.txt ]; then
+touch /boot/uEnv.txt
+rm -f /boot/uEnv.bak
+cp /boot/uEnv.txt /boot/uEnv.bak
+awk '/^kernel=/ { skip = 1; } /^dtb=/ { skip = 1; } /.*/ { if (skip) skip = 0; else print \$0; }' /boot/uEnv.txt > \${tmp_uenv}
+echo "kernel=/boot/uImage-\${1}" >> \${tmp_uenv}
+
+if [ -f /boot/\${uboot_kernel_dtb} ]; then
+  echo "dtb=\${uboot_kernel_dtb}" >> \${tmp_uenv}
+fi
+rm -f /boot/uEnv.txt
+mv \${tmp_uenv} /boot/uEnv.txt
+fi
+
+EOF
+
+cat <<EOF > "$tmpdir$debhookdir/prerm.d/cleanBoot"
+#!/bin/bash
+
+rm -f /etc/kernel/postinst.d/updateBoot
+rm -f /etc/kernel/prerm.d/cleanBoot
+
+EOF
+
+chmod 755 "$tmpdir$debhookdir/postinst.d/updateBoot"
+chmod 755 "$tmpdir$debhookdir/prerm.d/cleanBoot"
+
+
 # Try to determine maintainer and email values
 if [ -n "$DEBEMAIL" ]; then
        email=$DEBEMAIL
@@ -245,6 +306,10 @@
 # Build header package
 (cd $srctree; find . -name Makefile -o -name Kconfig\* -o -name \*.pl > "$objtree/debian/hdrsrcfiles")
 (cd $srctree; find arch/$SRCARCH/include include scripts -type f >> "$objtree/debian/hdrsrcfiles")
+(cd $srctree; find arch/$SRCARCH/plat-sunxi -type f >> "$objtree/debian/hdrsrcfiles")
+if echo arch/$SRCARCH/mach-*/include | grep -v '*' >/dev/null; then
+	(cd $srctree; find arch/$SRCARCH/mach-*/include -type f >> "$objtree/debian/hdrsrcfiles")
+fi
 (cd $objtree; find .config Module.symvers include scripts -type f >> "$objtree/debian/hdrobjfiles")
 destdir=$kernel_headers_dir/usr/src/linux-headers-$version
 mkdir -p "$destdir"
@@ -252,7 +317,7 @@
 (cd $objtree; tar -c -f - -T "$objtree/debian/hdrobjfiles") | (cd $destdir; tar -xf -)
 ln -sf "/usr/src/linux-headers-$version" "$kernel_headers_dir/lib/modules/$version/build"
 rm -f "$objtree/debian/hdrsrcfiles" "$objtree/debian/hdrobjfiles"
-arch=$(dpkg --print-architecture)
+arch=${DEB_HOST_ARCH}
 
 cat <<EOF >> debian/control
 
diff -ur linux-sunxi.vanilla/sound/soc/Kconfig linux-sunxi.patched/sound/soc/Kconfig
--- linux-sunxi.vanilla/sound/soc/Kconfig	2014-05-11 08:35:08.908550272 +0100
+++ linux-sunxi.patched/sound/soc/Kconfig	2014-05-11 08:37:47.290564962 +0100
@@ -60,7 +60,7 @@
 source "sound/soc/sunxi/hdmiaudio/Kconfig"
 source "sound/soc/sunxi/spdif/Kconfig"
 # i2s needs various adjustments for sun7i
-if ARCH_SUN4I || ARCH_SUN5I
+if ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I
 source "sound/soc/sunxi/i2s/Kconfig"
 endif
 endif
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/Kconfig linux-sunxi.patched/sound/soc/sunxi/i2s/Kconfig
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/Kconfig	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/Kconfig	2014-05-11 08:37:47.290564962 +0100
@@ -1,5 +1,5 @@
 config SND_SUNXI_SOC_I2S_INTERFACE
-	tristate "SoC i2s interface for the AllWinner sun4i and sun5i chips"
+	tristate "SoC i2s interface for the AllWinner sun4i, sun5i and sun7i chips"
 	default m
 	help
 	  Say Y or M if you want to add support for codecs attached to
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sndi2s.c linux-sunxi.patched/sound/soc/sunxi/i2s/sndi2s.c
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sndi2s.c	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sndi2s.c	2014-05-11 08:37:47.290564962 +0100
@@ -35,11 +35,23 @@
 };
 
 static int i2s_used = 0;
-#define sndi2s_RATES  (SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_KNOT)
+static int sunxi_i2s_slave = 0;
+
+#define sndi2s_RATES_MASTER  (SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_KNOT)
+#define sndi2s_RATES_SLAVE (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
+				SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\
+				SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
+
+#if defined CONFIG_ARCH_SUN7I
+#define sndi2s_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+#else
 #define sndi2s_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \
-		                     SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_3LE)
+		                     SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_LE)
+#endif
 
+/* cleaning code
 hdmi_audio_t hdmi_parameter;
+*/
 
 static int sndi2s_mute(struct snd_soc_dai *dai, int mute)
 {
@@ -62,8 +74,26 @@
 	struct snd_pcm_hw_params *params,
 	struct snd_soc_dai *dai)
 {
+/*
+	switch (params_format(params)) 
+	{
+	case SNDRV_PCM_FORMAT_S16_LE:
+		printk("[IIS-0] sndi2s_hw_params: format 16 bit\n");
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		printk("[IIS-0] sndi2s_hw_params: format 20 bit in 3 bytes\n");
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		printk("[IIS-0] sndi2s_hw_params: format 24 bit in 4 bytes\n");
+		break;
+	default:
+		printk("[IIS-0] sndi2s_hw_params: Unsupported format (%d)\n", (int)params_format(params));
+		//return -EINVAL;
+	}
+*/	
+/* cleaning code
 	hdmi_parameter.sample_rate = params_rate(params);
-
+*/
 	return 0;
 }
 
@@ -75,15 +105,18 @@
 
 static int sndi2s_set_dai_clkdiv(struct snd_soc_dai *codec_dai, int div_id, int div)
 {
-
+/* cleaning code
 	hdmi_parameter.fs_between = div;
-
+*/
 	return 0;
 }
 
 static int sndi2s_set_dai_fmt(struct snd_soc_dai *codec_dai,
 			       unsigned int fmt)
 {
+/*
+	printk("[IIS-0] sndi2s_set_dai_fmt: format (%u)\n", fmt);
+*/	
 	return 0;
 }
 
@@ -104,7 +137,7 @@
 		.stream_name = "Playback",
 		.channels_min = 1,
 		.channels_max = 2,
-		.rates = sndi2s_RATES,
+		.rates = sndi2s_RATES_MASTER,
 		.formats = sndi2s_FORMATS,
 	},
 	/* pcm operations */
@@ -129,10 +162,8 @@
 /* power down chip */
 static int sndi2s_soc_remove(struct snd_soc_codec *codec)
 {
-	struct sndhdmi_priv *sndi2s = snd_soc_codec_get_drvdata(codec);
-
+	struct sndi2s_priv *sndi2s = snd_soc_codec_get_drvdata(codec);
 	kfree(sndi2s);
-
 	return 0;
 }
 
@@ -143,6 +174,12 @@
 
 static int __devinit sndi2s_codec_probe(struct platform_device *pdev)
 {
+	if(sunxi_i2s_slave) {
+		sndi2s_dai.playback.rates = sndi2s_RATES_SLAVE;
+		printk("[I2S-0] sndi2s_codec_probe I2S used in slave mode\n");
+	}
+	else 
+		printk("[I2S-0] sndi2s_codec_probe I2S used in master mode\n");
 	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_sndi2s, &sndi2s_dai, 1);
 }
 
@@ -169,7 +206,7 @@
 static int __init sndi2s_codec_init(void)
 {
 	int err = 0;
-	int ret = 0;
+	int ret = 0, i2s_slave = 0;
 
 	ret = script_parser_fetch("i2s_para","i2s_used", &i2s_used, sizeof(int));
 	if (ret) {
@@ -177,6 +214,16 @@
     }
 
 	if (i2s_used) {
+		ret = script_parser_fetch("i2s_para","i2s_slave", &i2s_slave, sizeof(int));
+		if(ret == 0 && i2s_slave == 1) {
+			sunxi_i2s_slave = 1;
+			printk("[I2S-0] sndi2s_codec_init I2S used in slave mode\n");
+		}
+		else {
+			sunxi_i2s_slave = 0;
+			printk("[I2S-0] sndi2s_codec_init I2S used in master mode\n");
+		}
+	
 		if((err = platform_device_register(&sndi2s_codec_device)) < 0)
 			return err;
 
@@ -204,3 +251,4 @@
 MODULE_AUTHOR("Zoltan Devai, Christian Pellegrin <chripell@evolware.org>");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:sunxi-i2s-codec");
+
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sndi2s.h linux-sunxi.patched/sound/soc/sunxi/i2s/sndi2s.h
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sndi2s.h	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sndi2s.h	2014-05-11 08:37:47.290564962 +0100
@@ -16,6 +16,8 @@
 #ifndef SNDI2S_H_
 #define SNDI2S_H_
 
+#if 0
+cleaning code
 typedef struct hdmi_audio
 {
 	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
@@ -54,5 +56,6 @@
 		HDMI_CMD_AUDIO_ENABLE,
 		HDMI_CMD_GET_HPD_STATUS,
 }__hdmi_cmd_t;
+#endif
 
 #endif
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2s.c linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2s.c
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2s.c	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2s.c	2014-05-11 08:37:47.290564962 +0100
@@ -58,13 +58,15 @@
 };
 
 
- struct sunxi_i2s_info sunxi_iis;
+/* most of fields of this structure is never initialized and useless !!!*/
+struct sunxi_i2s_info sunxi_iis;
 static u32 i2s_handle = 0;
- static struct clk *i2s_apbclk, *i2s_pll2clk, *i2s_pllx8, *i2s_moduleclk;
+static struct clk *i2s_apbclk, *i2s_pll2clk, *i2s_pllx8, *i2s_moduleclk;
 
 void sunxi_snd_txctrl_i2s(struct snd_pcm_substream *substream, int on)
 {
 	u32 reg_val;
+	/*printk("[I2S-0] sunxi_snd_txctrl_i2s\n");*/
 
 	reg_val = readl(sunxi_iis.regs + SUNXI_TXCHSEL);
 	reg_val &= ~0x7;
@@ -73,7 +75,7 @@
 
 	reg_val = readl(sunxi_iis.regs + SUNXI_TXCHMAP);
 	reg_val = 0;
-	if (sunxi_is_sun4i()) {
+	if (sunxi_is_sun4i() || sunxi_is_sun7i()) {
 		if(substream->runtime->channels == 1) {
 			reg_val = 0x76543200;
 		} else {
@@ -89,7 +91,7 @@
 	writel(reg_val, sunxi_iis.regs + SUNXI_TXCHMAP);
 
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
-	if (sunxi_is_sun4i()) {
+	if (sunxi_is_sun4i() || sunxi_is_sun7i()) {
 		reg_val &= ~SUNXI_IISCTL_SDO3EN;
 		reg_val &= ~SUNXI_IISCTL_SDO2EN;
 		reg_val &= ~SUNXI_IISCTL_SDO1EN;
@@ -146,6 +148,8 @@
 
 		//Global Enable Digital Audio Interface
 		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		if(sunxi_iis.slave)
+			reg_val |= SUNXI_IISCTL_MS; // 1: Slave!
 		reg_val |= SUNXI_IISCTL_GEN;
 		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
 
@@ -170,7 +174,7 @@
 void sunxi_snd_rxctrl_i2s(int on)
 {
 	u32 reg_val;
-
+	/*printk("[I2S-0] sunxi_snd_rxctrl_i2s\n");*/
 	//flush RX FIFO
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISFCTL);
 	reg_val |= SUNXI_IISFCTL_FRX;
@@ -192,6 +196,8 @@
 
 		//Global Enable Digital Audio Interface
 		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		if(sunxi_iis.slave)
+			reg_val |= SUNXI_IISCTL_MS; // 1: Slave!
 		reg_val |= SUNXI_IISCTL_GEN;
 		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
 
@@ -201,7 +207,7 @@
 		reg_val &= ~SUNXI_IISCTL_RXEN;
 		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
 
-		/* DISBALE dma DRQ mode */
+		/* DISABLE dma DRQ mode */
 		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
 		reg_val &= ~SUNXI_IISINT_RXDRQEN;
 		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
@@ -213,11 +219,13 @@
 	}
 }
 
+//not used
+/*
 static inline int sunxi_snd_is_clkmaster(void)
 {
 	return ((readl(sunxi_iis.regs + SUNXI_IISCTL) & SUNXI_IISCTL_MS) ? 0 : 1);
 }
-
+*/
 static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 {
 	u32 reg_val;
@@ -225,7 +233,7 @@
 
 	//SDO ON
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
-	if (sunxi_is_sun4i()) {
+	if (sunxi_is_sun4i() || sunxi_is_sun7i()) {
 		reg_val |= (SUNXI_IISCTL_SDO0EN | SUNXI_IISCTL_SDO1EN |
 			    SUNXI_IISCTL_SDO2EN | SUNXI_IISCTL_SDO3EN);
 	} else {
@@ -235,16 +243,31 @@
 
 	/* master or slave selection */
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	if(sunxi_iis.slave)
+	{
+		reg_val |= SUNXI_IISCTL_MS; // 1: Slave!
+		/*printk("[IIS-0] sunxi_i2s_set_fmt: set slave mode for I2S interface\n");*/
+	}
+	else
+	{
+		reg_val &= ~SUNXI_IISCTL_MS; // 0: Master!
+		/*printk("[IIS-0] sunxi_i2s_set_fmt: set master mode for I2S interface\n");*/
+	}
+/*
 	switch(fmt & SND_SOC_DAIFMT_MASTER_MASK){
-		case SND_SOC_DAIFMT_CBM_CFM:   /* codec clk & frm master */
-			reg_val |= SUNXI_IISCTL_MS;
-			break;
-		case SND_SOC_DAIFMT_CBS_CFS:   /* codec clk & frm slave */
-			reg_val &= ~SUNXI_IISCTL_MS;
+		case SND_SOC_DAIFMT_CBS_CFS:   // codec clk & frm slave
+			reg_val |= SUNXI_IISCTL_MS; // 1: Slave!
+			printk("[IIS-0] sunxi_i2s_set_fmt: set slave mode for I2S interface\n");
+			break;
+		case SND_SOC_DAIFMT_CBM_CFM:   // codec clk & frm master
+			reg_val &= ~SUNXI_IISCTL_MS; // 0: Master!
+			printk("[IIS-0] sunxi_i2s_set_fmt: set master mode for I2S interface\n");
 			break;
 		default:
+			printk("[IIS-0] sunxi_i2s_set_fmt: not master or slave mode\n");
 			return -EINVAL;
 	}
+*/
 	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
 
 	/* pcm or i2s mode selection */
@@ -255,24 +278,30 @@
 		case SND_SOC_DAIFMT_I2S:        /* I2S mode */
 			reg_val &= ~SUNXI_IISCTL_PCM;
 			reg_val1 |= SUNXI_IISFAT0_FMT_I2S;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: set I2S mode\n");*/
 			break;
 		case SND_SOC_DAIFMT_RIGHT_J:    /* Right Justified mode */
 			reg_val &= ~SUNXI_IISCTL_PCM;
 			reg_val1 |= SUNXI_IISFAT0_FMT_RGT;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: set Right Justified mode\n");*/
 			break;
 		case SND_SOC_DAIFMT_LEFT_J:     /* Left Justified mode */
 			reg_val &= ~SUNXI_IISCTL_PCM;
 			reg_val1 |= SUNXI_IISFAT0_FMT_LFT;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: set Left Justified mode\n");*/
 			break;
 		case SND_SOC_DAIFMT_DSP_A:      /* L data msb after FRM LRC */
 			reg_val |= SUNXI_IISCTL_PCM;
 			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: set L data msb after FRM LRC mode\n");*/
 			break;
 		case SND_SOC_DAIFMT_DSP_B:      /* L data msb during FRM LRC */
 			reg_val |= SUNXI_IISCTL_PCM;
 			reg_val1 |= SUNXI_IISFAT0_LRCP;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: set L data msb during FRM LRC mode\n");*/
 			break;
 		default:
+			printk("[IIS-0] sunxi_i2s_set_fmt: unknown mode\n");
 			return -EINVAL;
 	}
 	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
@@ -284,25 +313,30 @@
 		case SND_SOC_DAIFMT_NB_NF:     /* normal bit clock + frame */
 			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
 			reg_val1 &= ~SUNXI_IISFAT0_BCP;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: normal bit clock + frame\n");*/
 			break;
 		case SND_SOC_DAIFMT_NB_IF:     /* normal bclk + inv frm */
 			reg_val1 |= SUNXI_IISFAT0_LRCP;
 			reg_val1 &= ~SUNXI_IISFAT0_BCP;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: normal bclk + inv frm\n");*/
 			break;
 		case SND_SOC_DAIFMT_IB_NF:     /* invert bclk + nor frm */
 			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
 			reg_val1 |= SUNXI_IISFAT0_BCP;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: invert bclk + nor frm\n");*/
 			break;
 		case SND_SOC_DAIFMT_IB_IF:     /* invert bclk + frm */
 			reg_val1 |= SUNXI_IISFAT0_LRCP;
 			reg_val1 |= SUNXI_IISFAT0_BCP;
+			/*printk("[IIS-0] sunxi_i2s_set_fmt: invert bclk + frm\n");*/
 			break;
 	}
 	writel(reg_val1, sunxi_iis.regs + SUNXI_IISFAT0);
 
-	/* word select size */
+	/* clear word select size */
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISFAT0);
 	reg_val &= ~SUNXI_IISFAT0_WSS_32BCLK;
+	/*printk("[IIS-0] sunxi_i2s_set_fmt: word size = %d\n", sunxi_iis.ws_size);*/
 	if(sunxi_iis.ws_size == 16)
 		reg_val |= SUNXI_IISFAT0_WSS_16BCLK;
 	else if(sunxi_iis.ws_size == 20)
@@ -318,9 +352,15 @@
 	reg_val |= sunxi_iis.pcm_rxtype<<2;
 
 	if(!sunxi_iis.pcm_sync_type)
+	{
 		reg_val |= SUNXI_IISFAT1_SSYNC;							//short sync
+		/*printk("[IIS-0] sunxi_i2s_set_fmt: set pcm_sync_type = short sync\n");*/
+	}
 	if(sunxi_iis.pcm_sw == 16)
+	{
 		reg_val |= SUNXI_IISFAT1_SW;
+		/*printk("[IIS-0] sunxi_i2s_set_fmt: pcm_sw == 16\n");*/
+	}
 
 	reg_val |=((sunxi_iis.pcm_start_slot - 1)&0x3)<<6;		//start slot index
 
@@ -349,6 +389,7 @@
 																struct snd_pcm_hw_params *params,
 																struct snd_soc_dai *dai)
 {
+	u32 reg_val;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct sunxi_dma_params *dma_data;
 
@@ -358,6 +399,31 @@
 	else
 		dma_data = &sunxi_i2s_pcm_stereo_in;
 
+	/* set format info */
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	/* clear sample resolution select size */
+	reg_val &= ~SUNXI_IISFAT0_SR_RVD;
+
+	switch (params_format(params)) 
+	{
+	case SNDRV_PCM_FORMAT_S16_LE:
+		reg_val |= SUNXI_IISFAT0_SR_16BIT;
+		/*printk("[IIS-0] sunxi_i2s_hw_params: format 16 bit\n");*/
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		reg_val |= SUNXI_IISFAT0_SR_20BIT;
+		/*printk("[IIS-0] sunxi_i2s_hw_params: format 20 bit\n");*/
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		reg_val |= SUNXI_IISFAT0_SR_24BIT;
+		/*printk("[IIS-0] sunxi_i2s_hw_params: format 24 bit\n");*/
+		break;
+	default:
+		printk("[IIS-0] sunxi_i2s_hw_params: Unsupported format (%d)\n", (int)params_format(params));
+		//return -EINVAL;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFAT0);
+
 	snd_soc_dai_set_dma_data(rtd->cpu_dai, substream, dma_data);
 	return 0;
 }
@@ -403,9 +469,17 @@
                                  unsigned int freq, int dir)
 {
 	if (!freq) {
-		clk_set_rate(i2s_pll2clk, 24576000);
+		/*printk("[IIS-0] sunxi_i2s_set_sysclk: set sysclk=24576000\n");*/
+		if(sunxi_iis.slave)
+			gpio_write_one_pin_value(i2s_handle, 0, "i2s_clk_sel");
+		else
+			clk_set_rate(i2s_pll2clk, 24576000);
 	} else {
-		clk_set_rate(i2s_pll2clk, 22579200);
+		/*printk("[IIS-0] sunxi_i2s_set_sysclk: set sysclk=22579200\n");*/
+		if(sunxi_iis.slave)
+			gpio_write_one_pin_value(i2s_handle, 1, "i2s_clk_sel");
+		else
+			clk_set_rate(i2s_pll2clk, 22579200);
 	}
 
 	return 0;
@@ -414,6 +488,27 @@
 static int sunxi_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
 {
 	u32 reg;
+	/*printk("[IIS-0] sunxi_i2s_set_clkdiv: PLL clock div_id=(%s), div=(%d)\n", 
+		div_id == SUNXI_DIV_MCLK ? "SUNXI_DIV_MCLK" : 
+		(div_id == SUNXI_DIV_BCLK ? "SUNXI_DIV_BCLK" : "SUNXI_DIV_EXTCLK"), div);*/
+
+
+	if(sunxi_iis.slave) {
+		if(div_id != SUNXI_DIV_EXTCLK) {
+			pr_err("[I2S-0] try to set external clock divider failed\n");
+			return -EINVAL;
+		}
+		/*printk("[IIS-0] sunxi_i2s_set_clkdiv: external clock, div=(%d)\n", div);*/
+	}
+	else {
+		if(div_id != SUNXI_DIV_MCLK && div_id != SUNXI_DIV_BCLK) {
+			pr_err("[I2S-0] try to set PLL clock divider failed\n");
+			return -EINVAL;
+		}
+		/*printk("[IIS-0] sunxi_i2s_set_clkdiv: PLL clock div_id=(%s), div=(%d)\n", 
+			div_id == SUNXI_DIV_MCLK ? "SUNXI_DIV_MCLK" : "SUNXI_DIV_BCLK", div);*/
+	}
+
 	switch (div_id) {
 		case SUNXI_DIV_MCLK:
 			if(div <= 8)
@@ -447,18 +542,39 @@
 			reg = (readl(sunxi_iis.regs + SUNXI_IISCLKD) & ~SUNXI_IISCLKD_BCLK_MASK) | (div <<SUNXI_IISCLKD_BCLK_OFFS);
 			writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
 			break;
+		case SUNXI_DIV_EXTCLK:
+			/*printk("[IIS-0] sunxi_i2s_set_clkdiv set divider=(%d)\n", div);*/
+			if(div == 512) {
+				gpio_write_one_pin_value(i2s_handle, 1, "i2s_clk_div1");
+				gpio_write_one_pin_value(i2s_handle, 1, "i2s_clk_div0");
+			}
+			else if(div == 256) {
+				gpio_write_one_pin_value(i2s_handle, 0, "i2s_clk_div1");
+				gpio_write_one_pin_value(i2s_handle, 1, "i2s_clk_div0");
+			}
+			else if(div == 128) {
+				gpio_write_one_pin_value(i2s_handle, 0, "i2s_clk_div1");
+				gpio_write_one_pin_value(i2s_handle, 0, "i2s_clk_div0");
+			}
+			else {
+				pr_err("[I2S-0] try to set unsupported external clock divider div=(%d)\n", div);
+				return -EINVAL;
+			}
+			break;
 		default:
 			return -EINVAL;
 	}
 
-	//diable MCLK output when high samplerate
+	//disable MCLK output when high samplerate or slave mode
 	reg = readl(sunxi_iis.regs + SUNXI_IISCLKD);
-	if (!(reg & 0xF)) {
+	if (!(reg & 0xF) || sunxi_iis.slave) {
 		reg &= ~SUNXI_IISCLKD_MCLKOEN;
 		writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+		/*printk("[IIS-0] sunxi_i2s_set_clkdiv: disable MCLK\n");*/
 	} else {
 		reg |= SUNXI_IISCLKD_MCLKOEN;
 		writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+		/*printk("[IIS-0] sunxi_i2s_set_clkdiv: enable MCLK\n");*/
 	}
 
 	return 0;
@@ -502,16 +618,17 @@
 	u32 reg_val;
 	printk("[IIS]Entered %s\n", __func__);
 
-	//Global Enable Digital Audio Interface
+	//Global Disable Digital Audio Interface
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
 	reg_val &= ~SUNXI_IISCTL_GEN;
 	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
 
 	iisregsave();
 
-	//release the module clock
-	clk_disable(i2s_moduleclk);
-
+	if(!sunxi_iis.slave) {
+		//release the module clock, only for master mode
+		clk_disable(i2s_moduleclk);
+	}
 	clk_disable(i2s_apbclk);
 
 	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
@@ -525,16 +642,21 @@
 	u32 reg_val;
 	printk("[IIS]Entered %s\n", __func__);
 
-	//release the module clock
+	//enable the module clock
 	clk_enable(i2s_apbclk);
 
-	//release the module clock
-	clk_enable(i2s_moduleclk);
+	if(!sunxi_iis.slave) {
+
+		//enable the module clock
+		clk_enable(i2s_moduleclk);
+	}
 
 	iisregrestore();
 
 	//Global Enable Digital Audio Interface
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	if(sunxi_iis.slave)
+		reg_val |= SUNXI_IISCTL_MS; // 1: Slave!
 	reg_val |= SUNXI_IISCTL_GEN;
 	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
 
@@ -545,7 +667,10 @@
 	return 0;
 }
 
-#define SUNXI_I2S_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+#define SUNXI_I2S_RATES_MASTER (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+#define SUNXI_I2S_RATES_SLAVE (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
+				SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\
+				SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
 static struct snd_soc_dai_ops sunxi_iis_dai_ops = {
 	.trigger 	= sunxi_i2s_trigger,
 	.hw_params 	= sunxi_i2s_hw_params,
@@ -562,14 +687,14 @@
 	.playback 	= {
 		.channels_min = 1,
 		.channels_max = 2,
-		.rates = SUNXI_I2S_RATES,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+		.rates = SUNXI_I2S_RATES_MASTER,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
 	},
 	.capture 	= {
 		.channels_min = 1,
 		.channels_max = 2,
-		.rates = SUNXI_I2S_RATES,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+		.rates = SUNXI_I2S_RATES_MASTER,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
 	},
 	.symmetric_rates = 1,
 	.ops 		= &sunxi_iis_dai_ops,
@@ -579,42 +704,60 @@
 {
 	int reg_val = 0;
 	int ret;
+	printk("[IIS]Entered %s\n", __func__);
 
 	sunxi_iis.regs = ioremap(SUNXI_IISBASE, 0x100);
 	if (sunxi_iis.regs == NULL)
 		return -ENXIO;
 
 	//i2s apbclk
-	i2s_apbclk = clk_get(NULL, "apb_i2s");
+	i2s_apbclk = clk_get(NULL, 
+#if defined CONFIG_ARCH_SUN7I
+		"apb_i2s0"
+#else
+		"apb_i2s"
+#endif
+		);
+
 	if(-1 == clk_enable(i2s_apbclk)){
 		printk("i2s_apbclk failed! line = %d\n", __LINE__);
 		goto out;
 	}
 
-	i2s_pllx8 = clk_get(NULL, "audio_pllx8");
-
-	//i2s pll2clk
-	i2s_pll2clk = clk_get(NULL, "audio_pll");
+	if(!sunxi_iis.slave) {
 
-	//i2s module clk
-	i2s_moduleclk = clk_get(NULL, "i2s");
-
-	if(clk_set_parent(i2s_moduleclk, i2s_pll2clk)){
-		printk("try to set parent of i2s_moduleclk to i2s_pll2ck failed! line = %d\n",__LINE__);
-		goto out1;
-	}
+		i2s_pllx8 = clk_get(NULL, "audio_pllx8");
+		//i2s pll2clk
+		i2s_pll2clk = clk_get(NULL, "audio_pll");
+		//i2s module clk
+		i2s_moduleclk = clk_get(NULL, 
+#if defined CONFIG_ARCH_SUN7I
+			"i2s0"
+#else
+			"i2s"
+#endif
+			);
+
+		if(clk_set_parent(i2s_moduleclk, i2s_pll2clk)){
+			printk("try to set parent of i2s_moduleclk to i2s_pll2ck failed! line = %d\n",__LINE__);
+			goto out1;
+		}
 
-	if(clk_set_rate(i2s_moduleclk, 24576000/8)){
-		printk("set i2s_moduleclk clock freq to 24576000 failed! line = %d\n", __LINE__);
-		goto out1;
-	}
+		if(clk_set_rate(i2s_moduleclk, 24576000/8)){
+			printk("set i2s_moduleclk clock freq to 24576000 failed! line = %d\n", __LINE__);
+			goto out1;
+		}
 
-	if(-1 == clk_enable(i2s_moduleclk)){
-		printk("open i2s_moduleclk failed! line = %d\n", __LINE__);
-		goto out1;
-	}
+		if(-1 == clk_enable(i2s_moduleclk)){
+			printk("open i2s_moduleclk failed! line = %d\n", __LINE__);
+			goto out1;
+		}
+	} else
+		sunxi_iis_dai.playback.rates = SUNXI_I2S_RATES_SLAVE;
 
 	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	if(sunxi_iis.slave)
+		reg_val |= SUNXI_IISCTL_MS; // 1: Slave!
 	reg_val |= SUNXI_IISCTL_GEN;
 	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
 
@@ -627,7 +770,8 @@
 
 	goto out;
 	out2:
-		clk_disable(i2s_moduleclk);
+		if(!sunxi_iis.slave)
+			clk_disable(i2s_moduleclk);
 	out1:
 		clk_disable(i2s_apbclk);
 	out:
@@ -636,17 +780,20 @@
 
 static int __devexit sunxi_i2s_dev_remove(struct platform_device *pdev)
 {
+	printk("[IIS]Entered %s\n", __func__);
+
 	if(i2s_used) {
 		i2s_used = 0;
-		//release the module clock
-		clk_disable(i2s_moduleclk);
+		if(!sunxi_iis.slave) {
+			//release the module clock
+			clk_disable(i2s_moduleclk);
 
-		//release pllx8clk
-		clk_put(i2s_pllx8);
-
-		//release pll2clk
-		clk_put(i2s_pll2clk);
+			//release pllx8clk
+			clk_put(i2s_pllx8);
 
+			//release pll2clk
+			clk_put(i2s_pll2clk);
+		}
 		//release apbclk
 		clk_put(i2s_apbclk);
 
@@ -674,15 +821,26 @@
 
 static int __init sunxi_i2s_init(void)
 {
-	int err = 0;
+	int err = 0, i2s_slave = 0;
 	int ret;
 
+	printk("[IIS]Entered %s\n", __func__);
+
 	ret = script_parser_fetch("i2s_para","i2s_used", &i2s_used, sizeof(int));
 	if (ret) {
-        printk("[I2S]sunxi_i2s_init fetch i2s using configuration failed\n");
-    }
+        	printk("[I2S]sunxi_i2s_init fetch i2s using configuration failed\n");
+	}
 
  	if (i2s_used) {
+		ret = script_parser_fetch("i2s_para","i2s_slave", &i2s_slave, sizeof(int));
+		if (ret == 0 && i2s_slave) {
+			sunxi_iis.slave = 1;
+			printk("[I2S-0] sunxi_i2s_init I2S used in slave mode\n");
+		} else {
+			sunxi_iis.slave = 0;
+			printk("[I2S-0] sunxi_i2s_init I2S used in master mode\n");
+		}
+
 		i2s_handle = gpio_request_ex("i2s_para", NULL);
 
 		if((err = platform_device_register(&sunxi_i2s_device)) < 0)
@@ -700,6 +858,7 @@
 
 static void __exit sunxi_i2s_exit(void)
 {
+	printk("[IIS]Entered %s\n", __func__);
 	platform_driver_unregister(&sunxi_i2s_driver);
 }
 module_exit(sunxi_i2s_exit);
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2sdma.c linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2sdma.c
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2sdma.c	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2sdma.c	2014-05-11 08:37:47.294564504 +0100
@@ -35,11 +35,15 @@
 static volatile unsigned int dmasrc = 0;
 static volatile unsigned int dmadst = 0;
 
+//DMA data width
+static unsigned int dma_width = 16;
+
+
 static const struct snd_pcm_hardware sunxi_pcm_hardware = {
 	.info			= SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				      SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
 				      SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
 	.rates			= SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
 	.rate_min		= 8000,
 	.rate_max		= 192000,
@@ -125,6 +129,20 @@
 	if (!dma)
 		return 0;
 
+	/* set DMA width for using in sunxi_pcm_prepare*/
+	switch(params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+		dma_width = 16;
+		break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+		dma_width = 32;
+		break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+		dma_width = 32;
+		break;
+	}
+	/*printk("[IIS-0] sunxi_pcm_hw_params: dma width %d bit\n", dma_width);*/
+
 	if (prtd->params == NULL) {
 		prtd->params = dma;
 		ret = sunxi_dma_request(prtd->params, 0);
@@ -196,10 +214,22 @@
 #else
 		dma_config_t codec_dma_conf;
 		memset(&codec_dma_conf, 0, sizeof(codec_dma_conf));
-		codec_dma_conf.xfer_type.src_data_width	= DATA_WIDTH_16BIT;
+
+		/*printk("[IIS-0] sunxi_pcm_prepare: DMA data width=(%d)\n", dma_width);*/
+		if(dma_width > 16)
+		{
+			codec_dma_conf.xfer_type.src_data_width	= DATA_WIDTH_32BIT;
+			codec_dma_conf.xfer_type.dst_data_width	= DATA_WIDTH_32BIT;
+		}
+		else
+		{
+			codec_dma_conf.xfer_type.src_data_width	= DATA_WIDTH_16BIT;
+			codec_dma_conf.xfer_type.dst_data_width	= DATA_WIDTH_16BIT;
+		}
 		codec_dma_conf.xfer_type.src_bst_len	= DATA_BRST_1;	
-		codec_dma_conf.xfer_type.dst_data_width	= DATA_WIDTH_16BIT;
+//		codec_dma_conf.xfer_type.src_bst_len	= DATA_BRST_4;	/*like SPDIF module?*/
 		codec_dma_conf.xfer_type.dst_bst_len	= DATA_BRST_1;
+//		codec_dma_conf.xfer_type.src_bst_len	= DATA_BRST_4;	/*like SPDIF module?*/
 		codec_dma_conf.address_type.src_addr_mode = NDMA_ADDR_INCREMENT;
 		codec_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_NOCHANGE;
 		codec_dma_conf.src_drq_type		= N_SRC_SDRAM;
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2sdma.h linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2sdma.h
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2sdma.h	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2sdma.h	2014-05-11 08:37:47.294564504 +0100
@@ -29,7 +29,7 @@
 };
 
 /* platform data */
-extern struct snd_soc_platform sunxi_soc_platform_i2s;
-extern struct sunxi_i2s_info sunxi_iis;
+//extern struct snd_soc_platform sunxi_soc_platform_i2s;
+//extern struct sunxi_i2s_info sunxi_iis;
 
 #endif //SUNXI_PCM_H_
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2s.h linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2s.h
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-i2s.h	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-i2s.h	2014-05-11 08:37:47.294564504 +0100
@@ -259,8 +259,9 @@
 
 /*------------------------------------------------------------*/
 /* Clock dividers */
-#define SUNXI_DIV_MCLK	0
-#define SUNXI_DIV_BCLK	1
+#define SUNXI_DIV_MCLK		0
+#define SUNXI_DIV_BCLK		1
+#define SUNXI_DIV_EXTCLK	2
 
 #define SUNXI_IISCLKD_MCLK_MASK   0x0f
 #define SUNXI_IISCLKD_MCLK_OFFS   0
@@ -269,7 +270,7 @@
 #define SUNXI_IISCLKD_MCLKEN_OFFS 7
 
 unsigned int sunxi_i2s_get_clockrate(void);
-extern struct sunxi_i2s_info sunxi_i2s;
+//extern struct sunxi_i2s_info sunxi_iis;
 //extern struct snd_soc_dai sunxi_iis_dai;
 
 extern void sunxi_snd_txctrl_i2s(struct snd_pcm_substream *substream, int on);
@@ -300,5 +301,5 @@
 
 };
 
-extern struct sunxi_i2s_info sunxi_i2s;
+//extern struct sunxi_i2s_info sunxi_iis;
 #endif
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-sndi2s.c linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-sndi2s.c
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-sndi2s.c	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-sndi2s.c	2014-05-11 08:37:47.294564504 +0100
@@ -29,9 +29,14 @@
 
 #include "sndi2s.h"
 
+/* cleaning code
 static struct clk *xtal;
 static int clk_users;
 static DEFINE_MUTEX(clk_lock);
+*/
+
+/* slave mode flag*/
+static int sunxi_i2s_slave = 0;
 
 #ifdef ENFORCE_RATES
 static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
@@ -62,6 +67,7 @@
 
 static void sunxi_sndi2s_shutdown(struct snd_pcm_substream *substream)
 {
+/* cleaning code
 	mutex_lock(&clk_lock);
 	clk_users -= 1;
 	if (clk_users == 0) {
@@ -70,6 +76,7 @@
 
 	}
 	mutex_unlock(&clk_lock);
+*/
 }
 
 typedef struct __MCLK_SET_INF
@@ -91,6 +98,14 @@
 
 } __bclk_set_inf;
 
+typedef struct __EXTCLK_SET_INF
+{
+    __u32       samp_rate;      // sample rate
+    __u16       clk_div;        // masterclock division
+    __u16       mpll;           // select mpll, 0 - 24.576 Mhz, 1 - 22.5792 Mhz
+
+} __extclk_set_inf;
+
 
 static __bclk_set_inf BCLK_INF[] =
 {
@@ -164,7 +179,45 @@
     {0xffffffff, 0, 0, 0},
 };
 
-static s32 get_clock_divder(u32 sample_rate, u32 sample_width, u32 * mclk_div, u32* mpll, u32* bclk_div, u32* mult_fs)
+static __extclk_set_inf  EXTCLK_INF[] =
+{
+    //44.1k bitrate
+    { 44100, 512,  1},
+    //48k bitrate
+    { 48000, 512,  0},
+    //88.2k bitrate
+    { 88200, 256,  1},
+    //96k bitrate
+    { 96000, 256,  0},
+    //176.4k bitrate
+    { 176400, 128,  1},
+    //192k bitrate
+    { 192000, 128,  0},
+
+    //end flag 0xffffffff
+    {0xffffffff, 0, 0}
+};
+
+
+static s32 get_clock_divder_slave(u32 sample_rate, u32 sample_width, u32* bclk_div, u32* mpll, u32* mult_fs)
+{
+	u32 i, ret = -EINVAL;
+
+	for(i=0; i< 100; i++) {
+		if(EXTCLK_INF[i].samp_rate == sample_rate) {
+			//set mpll and bclk division
+			*mpll = EXTCLK_INF[i].mpll;
+			*bclk_div = EXTCLK_INF[i].clk_div;
+			ret = 0;
+			break;
+		}
+		else if(EXTCLK_INF[i].samp_rate == 0xffffffff)
+			break;
+	}
+	return ret;
+}
+
+static s32 get_clock_divder_master(u32 sample_rate, u32 sample_width, u32 * mclk_div, u32* mpll, u32* bclk_div, u32* mult_fs)
 {
 	u32 i, j, ret = -EINVAL;
 
@@ -200,35 +253,77 @@
 	int ret = 0;
 	unsigned long rate = params_rate(params);
 	u32 mclk_div=0, mpll=0, bclk_div=0, mult_fs=0;
+/*
+	printk("[IIS-0] sunxi_sndi2s_hw_params: codec_dai=(%s), cpu_dai=(%s)\n", codec_dai->name, cpu_dai->name);
+	printk("[IIS-0] sunxi_sndi2s_hw_params: channel num=(%d)\n", params_channels(params));
+	printk("[IIS-0] sunxi_sndi2s_hw_params: sample rate=(%lu)\n", rate);
+
+	switch (params_format(params)) 
+	{
+	case SNDRV_PCM_FORMAT_S16_LE:
+		printk("[IIS-0] sunxi_sndi2s_hw_params: format 16 bit\n");
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		printk("[IIS-0] sunxi_sndi2s_hw_params: format 20 bit in 3 bytes\n");
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		printk("[IIS-0] sunxi_sndi2s_hw_params: format 24 bit in 4 bytes\n");
+		break;
+	default:
+		printk("[IIS-0] sunxi_sndi2s_hw_params: Unsupported format (%d)\n", (int)params_format(params));
+		//return -EINVAL;
+	}
+*/
+	if(!sunxi_i2s_slave) {
+		get_clock_divder_master(rate, 32, &mclk_div, &mpll, &bclk_div, &mult_fs);
+		printk("[IIS-0] get_clock_divder_master: rate=(%lu), mclk_div=(%d), mpll=(%d), bclk_div=(%d), mult_fs=(%d)\n", 
+			rate, mclk_div, mpll, bclk_div, mult_fs);
+	} else {
+		get_clock_divder_slave(rate, 32, &bclk_div, &mpll, &mult_fs);
+		printk("[IIS-0] get_clock_divder_slave: rate=(%lu), bclk_div=(%d), mpll=(%d), mult_fs=(%d)\n",
+			rate, bclk_div, mpll, mult_fs);
+	}
 
-	get_clock_divder(rate, 32, &mclk_div, &mpll, &bclk_div, &mult_fs);
-
+	//call sunxi_iis_set_fmt
 	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+			SND_SOC_DAIFMT_NB_NF/* | SND_SOC_DAIFMT_CBM_CFM*/);
 	if (ret < 0)
 		return ret;
 
+	//call sunxi_iis_set_fmt
 	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+			SND_SOC_DAIFMT_NB_NF/* | SND_SOC_DAIFMT_CBM_CFM*/);
 	if (ret < 0)
 		return ret;
 
+	//call sunxi_iis_set_sysclk
 	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , mpll, 0);
 	if (ret < 0)
 		return ret;
 
+	//call sndi2s_set_dai_sysclk
 	ret = snd_soc_dai_set_sysclk(codec_dai, 0 , mpll, 0);
 	if (ret < 0)
 		return ret;
 
-	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_MCLK, mclk_div);
-	if (ret < 0)
-		return ret;
+	if(!sunxi_i2s_slave) {
+		//call sunxi_iis_set_clkdiv	
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_MCLK, mclk_div);
+		if (ret < 0)
+			return ret;
 
-	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_BCLK, bclk_div);
-	if (ret < 0)
-		return ret;
+		//call sunxi_iis_set_clkdiv	
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_BCLK, bclk_div);
+		if (ret < 0)
+			return ret;
+	} else {
+		//call sunxi_iis_set_clkdiv	
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_EXTCLK, bclk_div);
+		if (ret < 0)
+			return ret;
+	}
 
+	//call sndi2s_set_dai_clkdiv
 	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, mult_fs);
 	if (ret < 0)
 		return ret;
@@ -243,7 +338,7 @@
 };
 
 static struct snd_soc_dai_link sunxi_sndi2s_dai_link = {
-	.name 			= "I2S",
+	.name 		= "I2S",
 	.stream_name 	= "SUNXI-I2S",
 	.cpu_dai_name 	= "sunxi-i2s.0",
 	.codec_dai_name = "sndi2s",
@@ -286,12 +381,26 @@
 
 static int __init sunxi_sndi2s_init(void)
 {
-	int ret, i2s_used = 0;
+	int ret, i2s_used = 0, i2s_slave = 0;
+
+	printk("[IIS]Entered %s\n", __func__);
 
 	ret = script_parser_fetch("i2s_para", "i2s_used", &i2s_used, 1);
 	if (ret != 0 || !i2s_used)
 		return -ENODEV;
 
+	script_parser_fetch("i2s_para","i2s_slave", &i2s_slave, sizeof(int));
+	if (i2s_slave)
+	{
+		sunxi_i2s_slave = 1;
+		printk("[I2S-0] sunxi_sndi2s_init I2S used in slave mode\n");
+	}
+	else
+	{
+		sunxi_i2s_slave = 0;
+		printk("[I2S-0] sunxi_sndi2s_init I2S used in master mode\n");
+	}
+
 	ret = platform_device_register(&sunxi_sndi2s_device);
 	if (ret < 0)
 		return ret;
diff -ur linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-sndi2s.h linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-sndi2s.h
--- linux-sunxi.vanilla/sound/soc/sunxi/i2s/sunxi-sndi2s.h	2014-05-11 08:35:08.984549315 +0100
+++ linux-sunxi.patched/sound/soc/sunxi/i2s/sunxi-sndi2s.h	2014-05-11 08:37:47.294564504 +0100
@@ -14,7 +14,7 @@
  */
 #ifndef SUNXI_SNDI2S_H_
 #define SUNXI_SNDI2S_H_
-
+/* cleaning code
 struct sunxi_sndi2s_platform_data {
 	int iis_bclk;
 	int iis_ws;
@@ -22,4 +22,5 @@
 	void (*power)(int);
 	int model;
 }
+*/
 #endif
